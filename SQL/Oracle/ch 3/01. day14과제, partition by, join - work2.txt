과제부터 work2 테이블

day15 157~177
----------------------------------------------
partition  by - 소규모 그룹에 대한 소규모그룹의 정렬
----------------------------------------------
select department_id, salary, employee_id, first_name
       , rank( ) over(
                        partition by department_id 
                        order by salary desc
                    ) as rank
from employees;



<179~ >
----------------------------------------------------
 join - 여러개의 테이블을 합쳐 원하는 정보를 한번에 볼 때 사용
 from절에 하나가 아닌 여러개의 테이블
----------------------------------------------------
1 null값이 많아지는 공간은 위험! -> L자 패턴
 -> 이럴때는 테이블을 2개로 쪼개서 만드는 것이 좋음

2 중복을 허용하지 않고 싶을 때 : 하나만 수정하면 전부 다 바뀌게 함!
 -> 나중에 수정 할 때, 용이하지 못함. 다 일일이 바꿔줘야하니까
      테이블 분리시키면 수정할 때, 테이블2에서 하나만 바꾸면 1도 다 바뀌니까! 

---------------------------------------------------------
 full outer join, cross join -모든 레코드 다 나와
---------------------------------------------------------
-무작위로 모든 레코드를 다 합쳐서 만든것 
from A, B -> A레코드*B레코드 = A*B가 나옴
  -> 본 테이블의 rnum(PK:고유키)을 분리된 테이블의 넘버(FK:참조키)로 가서
      조인한 정보에 교집합이 될 수 있는 녀석이 필요함

---------------------------------------------------------
 inner join (교집합끼리 묶어서 만들어지는 테이블) FK ->  PK의 참조키
---------------------------------------------------------
-기본적인 형태


-------------------------------------------------------
outer join -> A테이블에 B테이블을 확장해서 만들어
-------------------------------------------------------
교집합없어도, A테이블의 교집합없는 값은 레코드가 모두 null로나오길 바랄 때

 <누굴 기준으로 확장했는가?>
 left outer join  - 왼쪽null값
 right outer join  - 오른쪽 null값 


ex)
--사원의 근무 부서명 조회 (부서명이 원래 숫자인데, 이름으로 찍고싶어
--만약 두 테이블 다 갖고 있는 레코드명이면, 앞에 테이블 명 꼭 찍어줘야해!
--그리고 where로 교집합 ! -> where 없으면 full outer join됨
select * from employees;
select * from departments;

select e.employee_id, e.first_name, e.salary, e.department_id, d.department_name
from employees e, departments d
where e.department_id = d.department_id
order by 1 ;







