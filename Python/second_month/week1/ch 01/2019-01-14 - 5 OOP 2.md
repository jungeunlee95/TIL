

# 2019-01-14** - 5 OOP 2

http://pythontutor.com/visualize.html#mode=edit



# OOP with Python

## 용어 정리

```python
class Person:                      #=> 클래스 정의(선언) : 클래스 객체 생성
    species = '인간'               #=> 멤버 변수(데이터 어트리뷰트), 클래스 변수
    
    def __init__(self):
        self.name = '아이유'		  #=> 인스턴스가 독자적으로 가지고 있는 변수
        
    def greeting(self):            #=> 멤버 메서드(메서드)
        print(f'{self.name}')
        
iu = Person()       # 인스턴스 객체 생성
daniel = Person()   # 인스턴스 객체 생성
iu.name             # 데이터 어트리뷰트 호출
iu.greeting()       # 메서드 호출
```

```python
class Person:                   
    species = '인간' 				# 클래스 변수 :  클래스 내의 모든 인스턴스가 공유하고 있는 속성
    
    def __init__(self, name):
        self.name = name		 # 인스턴스 변수 : 각각의 인스턴스(객체)가 독립적으로 가진 속성
        
    def greeting(self):         
        print(f'{self.name}')

cr = Person('호날두')
iu = Person('아이유')

print(cr.name)  		# 호날두
print(cr.species)		# 인간

print(iu.name)			# 아이유
print(iu.species)		# 인간
```





---

## `self` : 인스턴스 객체 자기자신

- C++ 혹은 자바에서의 this 키워드와 동일함. 
- 특별한 상황을 제외하고는 무조건 메서드에서 `self`를 첫번째 인자로 설정한다.
- 메서드는 인스턴스 객체가 함수의 첫번째 인자로 전달되도록 되어있다.

```python
iu.greeting()
cr.greeting()
Person.species # Person이라는 공간에 있는 species라는 변수의 값을 확인할래

# 아이유
# 호날두
# '인간'

# ----------------------------------
Person.greeting(iu)  # 아이유
iu.greeting()		 # 아이유
# ----------------------------------


```

- 클래스 선언부 내부에서도 반드시 self를 통해 데이터 어트리뷰트에 접근 해야 합니다.





---

## 클래스-인스턴스간의 이름공간

- 클래스를 정의하면, 클래스 객체가 생성되고 해당되는 이름 공간이 생성된다. 
- 인스턴스를 만들게 되면, 인스턴스 객체가 생성되고 해당되는 이름 공간이 생성된다. 
- 인스턴스의 어트리뷰트가 변경되면, 변경된 데이터를 인스턴스 객체 이름 공간에 저장한다.
- 즉, 인스턴스에서 특정한 어트리뷰트에 접근하게 되면 인스턴스 -> 클래스 순으로 탐색을 한다.





---

## 생성자 / 소멸자

- 생성자는 인스턴스 객체가 생성될 때 호출되는 함수이며, 소멸자는 객체가 소멸되는 과정에서 호출되는 함수입니다.

```python
def __init__(self):
    print('생성될 때 자동으로 호출되는 메서드입니다.')

def __del__(self):
    print('소멸될 때 자동으로 호출되는 메서드입니다.')
__someting__
```

위의 형식처럼 양쪽에 언더스코어가 있는 메서드를 스페셜 메서드 혹은 매직 메서드라고 불립니다.

- 생성자 역시 메소드이기 때문에 추가적인 인자를 받을 수 있습니다
- 아래와 같이 모두 사용할 수 있습니다!

```python
def __init__(self, parameter1, parameter2):
    print('생성될 때 자동으로 호출되는 메서드입니다.')
    print(parameter1)

def __init__(self, *args):
    print('생성될 때 자동으로 호출되는 메서드입니다.')

def __init__(self, **kwagrs):
    print('생성될 때 자동으로 호출되는 메서드입니다.')
```

- 따라서, 생성자는 값을 초기화하는 과정에서 자주 활용됩니다. 
- 아래의 클래스 변수와 인스턴스 변수를 통해 확인해보겠습니다.



---

## 클래스 변수 / 인스턴스 변수

```python
class Person:
    population = 0              # 클래스 변수 : 모든 인스턴스가 공유함.

    def __init__(self, name):   
        self.name = name        # 인스턴스 변수 : 인스턴스별로 각각 가지는 변수
```



---

## 정적 메서드 / 클래스 메서드

- 메서드 호출을 인스턴스가 아닌 클래스가 할 수 있도록 구성할 수 있습니다. 
- 이때 활용되는게 정적 메서드 혹은 클래스 메서드입니다.
- 정적 메소드는 객체가 전달되지 않은 형태이며, 클래스 메서드는 인자로 클래스를 넘겨준다.

- staticmethod는 다음과 같이 정의됩니다.

```python
@staticmethod
def methodname():
    codeblock
```

- classmethod는 다음과 같이 정의됩니다.

```python
@classmethod
def methodname(cls):
    codeblock
```



---

## 실습문제 - 정적 메소드

> 계산기 class인 `Calculator`를 만들어봅시다.

- 정적 메소드 : 두 수를 받아서 각각의 연산을 한 결과를 반환(return)
  1. `add()` : 덧셈
  2. `sub()` : 뺄셈 
  3. `mul()` : 곱셈
  4. `div()` : 나눗셈



---

## 실습문제 - 종합1

> 사실 이전에 작성한 Mylist는 완벽하지 않았습니다. 
>
> 한번 제대로 된 자료구조를 만들어보겠습니다. 
>
> `Stack` 클래스를 간략하게 구현해봅시다.

> [Stack](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D) : 스택은 LIFO(Last in First Out)으로 구조화된 자료구조를 뜻합니다.

1. `empty()`: 스택이 비었다면 참을 주고,그렇지 않다면 거짓이 된다.
2. `top()`: 스택의 가장 마지막 데이터를 넘겨준다. 스택이 비었다면 None을 리턴해주세요.
3. `pop()`: 스택의 가장 마지막 데이터의 값을 넘겨주고 해당 데이터를 삭제한다. 스택이 비었다면 None을 리턴해주세요.
4. `push()`: 스택의 가장 마지막 데이터 뒤에 값을 추가한다. 리턴값 없음

**다 완료하신 분들은 repr을 통해 예쁘게 출력까지 해봅시다.**



---

## 연산자 오버라이딩(중복 정의)

- 파이썬에 기본적으로 정의된 연산자를 직접적으로 정의하여 활용할 수 있습니다. 
- 몇가지만 소개하고 활용해봅시다.

```
+  __add__   
-  __sub__
*  __mul__
<  __lt__
<= __le__
== __eq__
!= __ne__
>= __ge__
>  __gt__
```



---

# 상속

## 기초

- 클래스에서 가장 큰 특징은 '상속' 기능을 가지고 있다는 것이다. 
- 부모 클래스의 모든 속성이 자식 클래스에게 상속 되므로 코드재사용성이 높아집니다.

```python
class DerivedClassName(BaseClassName):
    code block
```



---

## super()

- 자식 클래스에 메서드를 추가 구현할 수 있습니다.
- 부모 클래스의 내용을 사용하고자 할 때, `super()`를 사용할 수 있습니다.

- 위의 코드를 보면, 상속을 했음에도 불구하고 동일한 코드가 반복됩니다. 



---

## 메소드 오버라이딩

- 메서드를 재정의할 수도 있습니다.



---





---

## 상속관계에서의 이름공간

- 기존에 인스턴스 -> 클래스순으로 이름 공간을 탐색해나가는 과정에서 상속관계에 있으면 아래와 같이 확장됩니다.
- 인스턴스 -> 자식 클래스 -> 부모 클래스 -> 전역



> ### 실습1
>
> > Teacher 클래스를 만들어보고 Student와 Teacher 클래스에 각각 다른 행동의 메소드들을 하나씩 추가해봅시다.



> ### 실습2
>
> > 사실 사람은 포유류입니다. 
> >
> > Animal Class를 만들고, Person클래스가 상속받도록 구성해봅시다.
> >
> > 변수나, 메소드는 자유롭게 만들어봅시다.