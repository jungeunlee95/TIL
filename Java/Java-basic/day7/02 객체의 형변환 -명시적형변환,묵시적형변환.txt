★★★★[ 객체의 형변환 ] -> 서로 상속 관계일때만 일어남
 : 얘를 쓰면 예민하지않고 둔감하게 만들 수 있음

 public class Printer{}
 public class LGPrint{}
 Printer p = new LGPrint ();  =>오류

 public class Printer{}
 public class LGPrint extends Printer {}
 Printer p = new LGPrint ();  => 가능! 객체의 형변환

---------------------------------------------------------------------------
 묵시적 형변환 - UP CASTING  -> 그림!@!@!@!@  자식의 주소값을 부모가 갖고 있는 것
--------------------------------------------------------------------------- 
 상위 클래스 =  하위 클래스            => 묵시적 형변환
 Printer p = new LGPrint (); 
 이건 오른쪽을 왼쪽에 대입한다는 것이 아니라, 자식이 부모에 있는 것을 사용할 수 있다.
 Printer p 가 LGPrint클래스에서 Print만 사용할 수 있고, LGPrint변수/메소드는 사용 불가
 
 만약 상위클래스의 프린트를 하위클래스가 사용(오버라이딩)하게 될 때, 
 상위 클래스에서 프린트를 호출하면 하위클래스의 오버라이딩된 프린트가 호출됨


---------------------------------------------------------------------------
 명시적 형변환 - DOWN CASTING     => 그림!@!@!@!@ 
 부모클래스가 이미 자식을 가리키고 있는 묵시적 형변환, 
 그리고 다시 그 화살표를 명시적으로 부모를 가리키게함.
 자식은 계속 자신의 클래스를 가리키고 있어야함
---------------------------------------------------------------------------
 상위 클래스 타입 자리에 올 수 있는 객체는 실제 가리키는 메모리가 하위 클래스 타입이여야 가능
 LGPrinter lg = (LGPrinter) p ;
 
 class Parent {}
 class Child extends Parent{} 일때, 
 Child c = (child) new Parent();   =>이 것만 쓰는 것은 불가능
 : 이렇게 되면 c가 가리키는 공간이 Parent만 만들어지고 Child는 안만들어짐
   근데 어떻게 c가 패런트를 child형으로 바꿔 Parent에는 Child가 없는데!

 Parent p = new Child();   묵시적 먼저 하고 나서.
      child c = (child) p;         명시적



